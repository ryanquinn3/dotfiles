# config for codespaces
export DEV_LOG_FORMAT="json"
export DOCKER_CONFIG=$HOME/.docker

export CLAUDE_CODE_DISABLE_FEEDBACK_SURVEY=1

export DEV_WORKSPACE_DIR=".ryanquinn3"
export CODESPACE_DISPLAY_NAME=$(echo "$CODESPACE_NAME" | grep -oP '^[^-]+-[^-]+' || echo "$CODESPACE_NAME")

WC_PKG="@vanta/web-client"

[[ "$TERM_PROGRAM" == "vscode" ]] && . "$(code --locate-shell-integration-path zsh)"

[ -z "$DOT_FILES" ] && export DOT_FILES="/workspaces/.codespaces/.persistedshare/dotfiles"

# use personal gh token for gh cli
alias pgh="GH_TOKEN=$GH_GIST_TOKEN gh"

# aliases
alias gt="turbo generate-types --output-logs errors-only --filter @vanta/web --filter $WC_PKG"
alias gtc="turbo generate-types --output-logs errors-only --filter $WC_PKG"
alias syncdot="(cd $DOT_FILES && git pull) && rz"

alias tbr="_run_turbo_task"
alias jfz="_run_just"

alias brew_bundle="(cd $DOT_FILES && brew bundle --file brew/BrewFile) && rz"

alias start_web="just dev-start-web -d"
alias sm="docker compose up --detach mongo.internal"
alias rstc="restart_container"
alias rstc_w="restart_container web.internal"
alias rstc_wc="restart_container obsidian_web-client.internal_1"
alias cat="bat"
alias logs_web="docker compose logs web.internal --tail 100 --no-log-prefix"
alias logs_wc="docker compose logs web-client.internal --tail 100 --no-log-prefix"

# dont let homebrew version mess with system python
alias python3="/usr/bin/python3"

alias pr_create="gh pr create --draft --editor --template pull_request_template.md --base main"

# fzf
export FZF_DEFAULT_COMMAND="$SHELL -c 'fd --hidden --strip-cwd-prefix --exclude .git --no-ignore-vcs'"
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
export FZF_ALT_C_COMMAND="$SHELL -c 'fd --type=d --hidden --strip-cwd-prefix --exclude .git --no-ignore-vcs'"

[ -z "$TMUX" ] && tmux setenv -g CODESPACE_DISPLAY_NAME $CODESPACE_DISPLAY_NAME

# Functions
login_link(){
  json_line=$(logs_web 2>/dev/null  | \
   grep 'loginLink":' | \
   tail -n 1 )
  echo "{$json_line}" | jq -r .loginLink
}

function startc(){
  docker compose up -d "$1.internal"
}

function restart_container() {
  docker_ps | grep $1 | xargs -I {} docker restart {}
}

# new branch from main
nb(){
  # check if branch name is provided
  if [ -z "$1" ]; then
    echo "Usage: nb <branch-name>"
    return 1
  fi
  syncb && gco -b rq/$1 main
}

lint_ts(){
  files_to_lint=$(git diff HEAD --name-only --diff-filter=d | grep -E '.tsx?$')
  echo "Linting $(echo $files_to_lint | wc -l) files"
  start=`date +%s`
  npx eslint --quiet --fix $(git diff HEAD --name-only --diff-filter=d | grep -E '.tsx?$' )
  end=`date +%s`
  runtime=$((end-start))
  echo "Linted in $runtime seconds"
}

logs(){
  docker compose logs $1.internal --tail 100 --no-log-prefix $2
}

# emit a docker containers logs as json with some logic to drop annoying fields
logs_json(){
  logs "$1" "${@:2}" | jq -R '. as $line | try (fromjson | del(.dd, .networkInfo)) catch { message: $line }'
}
# Claude code boot up
clc(){
  GITHUB_TOKEN= ANTHROPIC_API_KEY= claude --dangerously-skip-permissions --permission-mode plan "$@"
}

function logs_ts(){
  local service=$1
  if [[ -z "$service" ]]; then
    echo "Usage: logs_ts <service-name>"
    return 1
  fi
  docker compose logs "$service.internal" --no-log-prefix -f \
  | grep --line-buffered '^{' \
  | jq --unbuffered -c '. + {timestamp: (now | strflocaltime("%Y-%m-%dT%H:%M:%S%Z"))}' 
}

function logs_lnav(){
  local service=$1
  if [[ -z "$service" ]]; then
    echo "Usage: logs_lnav <service-name>"
    return 1
  fi
  logs_ts "$service" | lnav
}

 

# check if python is /workspaces/obsidian/.venv/bin and only activate if is not
if [ "$(which python)" != "/workspaces/obsidian/.venv/bin/python" ]; then
  source /workspaces/obsidian/.venv/bin/activate
fi

function stamp(){
  if [ -z "$1" ]; then
    echo "Usage: stamp PR_NUMBER"
    return 1
  fi
   gh pr review --approve $1  
}

custom_comp_dir=~/.zsh/completions

# if $custom_comp_dir/_docker doesnt exist and docker command exists
if command -v docker &> /dev/null && [ ! -f $custom_comp_dir/_docker ]; then
  docker completion zsh > $custom_comp_dir/_docker
fi

eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"

# if $custom_comp_dir/_turbo doesnt exist and turbo command exists
if command -v turbo &> /dev/null && [ ! -f $custom_comp_dir/_turbo ]; then
  turbo completion zsh > $custom_comp_dir/_turbo
fi

function new_prompt(){
  [ -z "$1" ] && { echo "Usage: new_prompt NAME"; return 1; }
  touch .ryanquinn3/$1.md
}


# Fast turbo task runner with fzf selection
# Caches task list in temp file for performance
# Output format: $PACKAGE_NAME#$TASK_NAME
# Ignores the "//" package
# To refresh cache: rm /tmp/.turbo_tasks_cache
function _run_turbo_task() {
  local cache_file="/tmp/.turbo_tasks_cache"

  # Check if cache exists
  if [[ -f "$cache_file" ]]; then
    # Use cached tasks
    local flat_tasks
    flat_tasks=$(<"$cache_file")
  else
    # Generate fresh task list and cache it
    local task_json
    # pipe stderr to /dev/null to avoid noisy output
    task_json=$(turbo query "query { packages { items { name tasks { items { name} }} } }" 2>/dev/null)

    local flat_tasks
    flat_tasks=$(echo "$task_json" | jq -r '.data.packages.items[] | select(.name != "//") | .name as $pkg | .tasks.items[].name | "\($pkg)#\(.)"')

    # Cache the result
    echo "$flat_tasks" > "$cache_file"
  fi

  # Use fzf to select and run task
  local selected_task
  selected_task=$(print -r -- "$flat_tasks" | fzf)

   if [[ -n "$selected_task" ]]; then
    # what you actually execute (properly quoted)
    turbo "$selected_task" --output-logs="errors-only"

    # what you store in history (escaped so â†‘ works)
    local hist_cmd="turbo ${selected_task}"
    hist_cmd=${hist_cmd//\\/\\\\}  # escape backslashes first
    hist_cmd=${hist_cmd//\#/\\#}   # escape '#'
    hist_cmd=${hist_cmd//\!/\\!}   # escape '!'
    print -s -- "$hist_cmd"        # append to zsh history without expansion
  fi
}

function _run_just(){
  recipe=$(just | bat | fzf | awk '{ print $1 }')
   history -s "just $recipe"
  just $recipe
}

function dev-workspace-push(){
  aws-vault exec devadmin -- aws s3 sync ".$DEV_WORKSPACE_DIR" "s3://vanta-dev-codespace-assets/$DEV_WORKSPACE_DIR"
}
  
function dev-workspace-pull(){
  aws-vault exec devadmin -- aws s3 sync "s3://vanta-dev-codespace-assets/$DEV_WORKSPACE_DIR" ".$DEV_WORKSPACE_DIR"
}

